# MemoryPoolsAllocator

## Описание

Аллокатор, работающий на основе выделенных заранее блоков памяти, соответсвующий [требованиям к аллокаторам](https://en.cppreference.com/w/cpp/named_req/Allocator).
Размеры пулов, их количество, а также размеры кусочков - параметризуются (в compile time или runtime).

## Принцип работы

- Для аллокации памяти аллокатор использует заранее выделенные участки памяти
- Память изначальльно выделяется [пулами](https://en.wikipedia.org/wiki/Memory_pool)
- Пулы бьются на кусочки одинакового размера
- Пул умеет выделять и освобождать память только кусочками (один или более)
- Пул обладает информацией о свободных и занятых кусочках
- Пул очищает память лишь в конце своей "жизни"
- Аллокатор при выделение памяти размер N байт ищет среди пулов наиболее подходящий так, чтобы наиболее оптимально выделять память, если это невозможно то выбрасывается исключение std::bad_alloc
- При освобождении через аллокатор, кусочки памяти вновь пригодны для использования

## Реализация

При старте работы аллокатор выделяет заданное количество пулов **Block** и чанков **FreeChunks** (кусочки, на которые бьются пулы). 

Пулы и чанки хранятся в аллокаторе в виде двусвязного связного списка. Чанк содержит в себе размер, указатель на свое начало и указатели на предыдущий и следующий чанк. Последний чанк текущего блока указывает на первый чанк следующего блока. Блок же хранит просто указатель на свое начало и на следующий элемент (односвязный список). Блоки нужны для деаллокации и перевыделения. 

Изначально размер каждого чанка и указатель на начало равны соответсвующим характеристикам блока, в котором они содержатся. 

### Аллокация
При аллокации, пока размер чанка больше, чем запрашиваемое количество памяти, мы уменьшаем размер чанка на это число, и с помощью арифметики указателей двигаем начало. Если размер текущего чанка меньше, чем запрашиваемый размер, то мы переключаемся на следующий и так далее. Если подходящего чанка не нашлось, то выбрасывается std::bad_alloc.

### Деаллокация 

При деаллокации ищется подходящий блок (начало которого меньше, чем адрес освобождающейся памяти, а конец больше). Когда нашелся, итерируемся по свободным чанкам и ищем подходящее место. Если конец предыдущего и начало освобожденного сливается, то объединяем блоки. Аналогично, если конец текущего и начало следующего совпадают.

### Бенчмарк

Было произведено сравнение со стандартным аллокатором для методов **push_back** и **pop_back** контейнера std::list<long double>. 


**push_back**:



**pop_back**
